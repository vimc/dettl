#' Get default load function.
#'
#' Builds the default load function using foreign key constraints read from
#' the database.
#'
#' The default load function loops over the transformed data and appends each
#' data frame to the matching table in the database. If the appended table
#' contains a key referenced by one of the foreign key constraints then when
#' the data is inserted into the database this returns the value of the key for
#' the new rows. Then loop over all tables in which this is used as a foreign
#' key and update the previous values to use the returned actual values for the
#' referenced key.
#'
#' @return The default load function.
#'
#' @keywords internal
get_default_load <- function() {
  function(transformed_data, con) {
    rewrite_keys <- ForeignKeyConstraints$new(con)
    for (name in names(transformed_data)) {
      has_serial_foreign_keys <- rewrite_keys$used_as_foreign_key(name) &&
                                 rewrite_keys$has_serial(name)
      if (has_serial_foreign_keys) {
        referenced_keys <- rewrite_keys$get_referenced_keys(name)
        ## We only want to strip and use DB generated values for serial keys
        ## as these will be autogenerated on upload
        serials <- rewrite_keys$is_serial(name, referenced_keys)
        serial_keys <- referenced_keys[serials]
        insert_data <- strip_referenced_key_columns(transformed_data[[name]],
                                                    serial_keys)
        return <- insert_into_returning(con, name, insert_data,
                                        return = serial_keys)
        for (col in names(return)) {
          table_key_pair <- rewrite_keys$get_foreign_key_usages(name, col)
          old_key_values <- transformed_data[[name]][, col]
          transformed_data <- update_child_tables(
            transformed_data, table_key_pair, old_key_values, return[[col]], name)
        }
      } else {
        withCallingHandlers(
          DBI::dbWriteTable(con, name, transformed_data[[name]], append = TRUE),
          error = function(e) {
            readable_data <- paste(
              utils::capture.output(print(transformed_data[[name]])),
              collapse = "\n")
            e$message <- paste0(sprintf("Failed trying to append data:\n%s\n",
                                        readable_data),
                                sprintf("to table '%s':\n", name),
                                e$message)
            stop(e)
          }
        )
      }
    }
  }
}

strip_referenced_key_columns <- function(data, referenced_keys) {
  columns <- which(!(names(data) %in% referenced_keys))
  data[, columns, drop = FALSE]
}

#' Update child tables using inserted foreign keys
#'
#' @param tables List of tables to be updated.
#' @param table_key_pair List of child tables and the foreign key field.
#' @param old_key_values Old values of referenced key, how foreign key is
#' currently identified in child table.
#' @param new_key_values New values of referenced key, what foreign key should
#' be updated to.
#' @param parent_table The name of the table just updated
#'
#' @return The updated tables
#'
#' @keywords internal
update_child_tables <- function(tables, table_key_pair, old_key_values,
                                new_key_values, parent_table) {
  update1 <- function(table_name) {
    table <- tables[[table_name]]
    ## TODO: We remove the table we have just updated from the list of child
    ## tables. This means that any if we have a table where one of the columns
    ## has a foreign key constraint on another column within the same table (e.g.
    ## a hierachy where we have a parent column which refers to the PK of the
    ## the table itself) then that column will not be updated.
    ## We can't currently work around this as we add all new rows to the table in
    ## one go, to do this would require uploading row by row then checking for
    ## updated autogenerated rows within the same table.
    if (!is.null(table_key_pair[[table_name]]) && table_name != parent_table) {
      foreign_key <- table_key_pair[[table_name]]
      table[, foreign_key] <-
        unlist(map_values(table[, foreign_key], old_key_values, new_key_values),
               FALSE, FALSE)
    }
    table
  }
  list_names <- names(tables)
  tables <- lapply(list_names, update1)
  names(tables) <- list_names
  tables
}

## Update any old values within data to new ones
## Values must be unique in old and new
map_values <- function(data, old, new) {
  stopifnot(length(unique(old)) == length(old) &&
            length(unique(new)) == length(new) &&
            length(new) == length(old))
  ## Note that at the moment this won't work if in the old data there is a mix
  ## of references to newly added data and existing data from the database
  ## TODO: support a mix
  indices <- vnapply(data, function(x) {
    which(old == x)
  })
  new[indices]
}
